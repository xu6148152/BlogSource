---
title: 设计模式
tags: 设计模式
---
[代码示例](https://github.com/xu6148152/Design-Patterns)   

>1. 单一职责原则
>2. 接口隔离(多用组合，少用继承)
>3. 依赖倒置(高层不依赖低层，都依赖抽象)
>4. 里氏替换(子类必须能够替换基类)
>5. 迪米特原则(解耦，类之间尽量减少联系)
>6. 开闭原则(开放拓展，关闭修改)

### 设计原则

>  
> 1. 封装变化
2. 针对接口编程(针对超类型编程)，而不是针对实现编程
3. 多用组合，少用继承
4. 为了交互对象之间的松耦合设计而努力
5. 对拓展开放，对修改关闭
6. 最少知识(墨忒耳法则(Law of Demeter))
7. 好莱坞原则，别调用我们，我们会调用你
8. 一个类应该只有一个引起变化的原因
9. 依赖倒置原则(不能让高层组件依赖低层组件，两者都应该依赖于抽象)
   * 变量不可以持有具体类的引用
   * 不要让类派生自具体类
   * 不要覆盖基类中已实现的方法


#### 策略模式

>定义了算法族，分别封装起来，让它们之间可以互相替换，让算法的变化独立于使用算法的客户 

#### 观察者模式
>定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新

#### 装饰这模式
>动态地将责任附加到对象上。若要拓展功能，装饰着提供了比继承更有弹性的替代方案

#### 工厂方法模式  
* 方法工厂  

>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类  

* 抽象工厂

>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类  

#### 单件模式
>确保一个类只有一个实例，并提供一个全局访问点

#### 命令模式
>"请求"封装成对象，以便使用不同的请求，列队或者日志来参数化其他对象。命令模式也支持可撤销的操作

#### 适配器模式
>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类型可以合作无间。

* 对象适配器
* 类适配器(需要多重继承，java不支持)

#### 外观模式
>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

#### 模板方法模式
>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤

#### 迭代器模式
>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示

#### 组合模式
>允许你将对象组合成树形结构来表现"整体/部分"层次结构。组合能让客户以一致的方式处理对象以及对象组合

####状态模式
>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了类。策略模式和状态模式是双胞胎，在出生时才分开

#### 代理模式
>为另一个对象提供一个替身或占位符以控制对这个对象的访问，远程代理，虚拟代理,动态代理

#### 桥接模式
>把事物抽象和其具体行为、具体特征分离开来，使它们可以各自独立的变化 
>
 * 使实现解耦，让它和界面之间不再永久绑定
 * 抽象和实现可以独立拓展，不会影响对方
 * 对于“具体的抽象类”所做的改变，不会影响到客户。
 * 增加复杂度

#### 生成器
>封装一个产品的构造过程，并允许按步骤构造。
>
  * 将一个复杂对象的创建过程封装起来
  * 允许对象通过多个步骤来创建，并且可以改变过程
  * 向客户隐藏产品内部的表现
  * 产品的实现可以被替换，因为客户只看到一个抽象的接口

#### 责任链
>让一个以上的对象有机会能够处理某个请求的。
>
  * 将请求的发送者和接受者解耦
  * 可以简化对象，因为它不需要知道链的结构。
  * 通过改变链内的成员或调动它们的次序，允许你动态地新增或者删除责任
  
#### 享元模式(Flyweight)  
>让某个类的实例能够用来提供许多“虚拟实例”。
>
  * 减少运行时对象实例的个数，节省内存
  * 将许多“虚拟”对象的状态集中管理

#### 解释器(Interpreter)
>未语言创建解释器
>
  * 将每一种语法规则表示成一个类，方便于实现语言
  * 因为语法由许多类组成，所以可以轻易改变或拓展此语言
  * 通过在类结构中加入新的方法，可以在解释的同时增加新的行为

#### 中介者(Mediator)
>集中相关对象之间复杂的沟通和控制方式
>
  * 将对象彼此解耦，增加对象的复用性
  * 集中控制逻辑，简化系统维护
  * 让对象之间所传递的信息变得简单而且大幅减少

#### 备忘录
>让对象返回之前的状态
>
  * 将被存储的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚
  * 保持关键对象的数据封装
  * 提供了容易实现的恢复能力
  
#### 原型
>创建对象的种类，并且通过拷贝这些原型创建新的对象
>
  * 对客户隐藏创建新实例的复杂性
  * 提供让客户能够产生未知类型对象的选项  
  
#### 访问者
>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。
>
  * 允许对组合结构加入新的操作，而无需改变结构本身
  * 想要加入新的操作，相对容易
  * 访问者所进行的操作，其代码是集中在一起的  




### 参考
[Head First](https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_5?ie=UTF8&qid=1478679780&sr=8-5&keywords=%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)  
[设计模式:可复用面向对象软件的基础](https://www.amazon.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%9B%E4%B9%A6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80-Erich-Gamma/dp/B001130JN8/ref=sr_1_1?ie=UTF8&qid=1478679820&sr=8-1&keywords=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)